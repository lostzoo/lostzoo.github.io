---
title: 多线程快速入门
date: 2021-01-16
categories:
  - 并发编程
  - 多线程基础
tags:
  - 并发编程
---

# 多线程基础

## 线程与进程区别

每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。线程是一组指令的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。使用线程可以把占据时间长的程序中的任务放到后台去处理，程序的运行速度可能加快，在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下可以释放一些珍贵的资源如内存占用等等。如果有大量的线程,会影响性能，因为操作系统需要在它们之间切换，更多的线程需要更多的内存空间，线程的中止需要考虑其对程序运行的影响。通常块模型数据是在多个线程间共享的，需要防止线程死锁情况的发生。

**总结:进程是所有线程的集合，每一个线程是进程中的一条执行路径**

## 多线程创建方式

1. 第一种继承 Thread 类 重写 run 方法
2. 第二种实现 Runnable 接口,重写 run 方法
3. 第三种使用匿名内部类方式

## 获取线程对象以及名称

### 常用方法

- **start() 启动线程**
- **currentThread() 获取当前线程对象**
- getID() 获取当前线程 ID Thread-编号   该编号从 0 开始
- getName() 获取当前线程名称
- **sleep(long mill) 休眠线程**
- Stop() 停止线程

### 常构造函数

- Thread() 分配一个新的 Thread 对象
- Thread(String name) 分配一个新的 Thread 对象，具有指定的 name 正如其名。
- **Thread(Runable r) 分配一个新的 Thread 对象**
- Thread(Runable r, String name) 分配一个新的 Thread 对象

## 守护线程

Java 中有两种线程，一种是用户线程，另一种是守护线程。
**用户线程**是指用户自定义创建的线程，主线程停止，用户线程不会停止。
**守护线程**当进程不存在或主线程停止，守护线程也会被停止。
**使用 setDaemon(true)方法设置为守护线程**

## 多线程运行状态

> 线程从创建、运行到结束总是处于下面五个状态之一：新建状态、就绪状态、运行状态、阻塞状态及死亡状态。

### 新建状态

当用 new 操作符创建一个线程时， 例如 new Thread(r)，线程还没有开始运行，此时线程处在新建状态。 **当一个线程处于新生状态时，程序还没有开始运行线程中的代码**。

### 就绪状态

一个新创建的线程并不自动开始运行，要执行线程，必须调用线程的 start()方法。当线程对象调用 start()方法即启动了线程，start()方法创建线程运行的系统资源，并调度线程运行 run()方法。**当 start()方法返回后，线程就处于就绪状态。处于就绪状态的线程并不一定立即运行 run()方法，线程还必须同其他线程竞争 CPU 时间，只有获得 CPU 时间才可以运行线程**。因为在单 CPU 的计算机系统中，不可能同时运行多个线程，一个时刻仅有一个线程处于运行状态。因此此时可能有多个线程处于就绪状态。对多个处于就绪状态的线程是由 Java 运行时系统的线程调度程序(thread scheduler)来调度的。

### 运行状态

当线程获得 CPU 时间后，它才进入运行状态，真正开始执行 run()方法.

### 阻塞状态

线程运行过程中，可能由于各种原因进入阻塞状态:

- 线程通过调用 sleep 方法进入睡眠状态；
- 线程调用一个在 I/O 上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；
- 线程试图得到一个锁，而该锁正被其他线程持有；
- 线程在等待某个触发条件；

### 死亡状态

有两个原因会导致线程死亡：

- run 方法正常退出而自然死亡，
- 一个未捕获的异常终止了 run 方法而使线程猝死。

为了确定线程在当前是否存活着(就是要么是可运行的，要么是被阻塞了)，需要使用 isAlive 方法。如果是可运行或被阻塞，这个方法返回 true； 如果线程仍旧是 new 状态且不是可运行的， 或者线程死亡了，则返回 false.

## join 方法作用

当在主线程当中执行到 t1.join()方法时，就认为主线程应该把执行权让给 t1

## 优先级

现代操作系统基本采用时分的形式调度运行的线程，线程分配得到的时间片的多少决定了线程使用处理器资源的多少，也对应了线程优先级这个概念。在 JAVA 线程中，通过一个 int priority 来控制优先级，范围为 1-10，其中 10 最高，默认值为 5。

## Yield 方法

Thread.yield()方法的作用：暂停当前正在执行的线程，并执行其他线程。(可能没有效果)。yield()让当前正在运行的线程回到可运行状态，以允许具有相同优先级的其他线程获得运行的机会。因此，使用 yield()的目的是让具有相同优先级的线程之间能够适当的轮换执行。但是，实际中无法保证 yield()达到让步的目的，因为，让步的线程可能被线程调度程序再次选中。

**结论：大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。**

## FQA

### 1.进程与线程的区别？

答:进程是所有线程的集合，每一个线程是进程中的一条执行路径，线程只是一条执行路径。

### 2.多线程创建方式？

答:继承 Thread 或 Runnable 接口。

### 3.为什么要使用多线程？多线程应用场景？

答:主要能体现到多线程提高程序效率。
举例: 迅雷多线程下载、数据库连接池、分批发送短信等。

### 4.使用继承 Thread 类还是使用实现 Runnable 接口好？

使用实现实现 Runnable 接口好，原因实现了接口还可以继续继承，继承了类不能再继承。

### 5.启动线程是使用调用 start 方法还是 run 方法？

开始执行线程 注意 开启线程不是调用 run 方法，而是 start 方法
调用 run 知识使用实例调用方法。
